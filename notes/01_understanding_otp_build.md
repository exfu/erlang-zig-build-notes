# 01_understanding_otp.md

This document serves as a central point for understanding the journey of compiling Erlang/OTP with Zig. It consolidates the initial roadmap and provides more detailed insights for potential contributors.

**Introduction**

The goal of this project is to build Erlang/OTP (Open Telecom Platform) from scratch using only the Zig programming language as the build system. This means we aim to replace the traditional reliance on C compilers and Makefiles with a build process defined entirely in Zig.

This is an ambitious undertaking driven by the desire for a potentially cleaner, faster, and more auditable build process. The initial Minimum Viable Product (MVP) will target the Linux operating system.

**Challenges Ahead:**

* Erlang/OTP's core, especially the BEAM virtual machine (`erts`), is primarily written in C.
* The existing build system is complex, involving Autotools, Makefiles, and shell scripts.
* Erlang/OTP has dependencies on various system libraries and potentially external C libraries.
* Bootstrapping the Erlang compiler itself within a pure Zig environment presents a unique challenge.

**1. Understanding the Current Erlang/OTP Build System**

Before we can build Erlang/OTP with Zig, we need a solid understanding of how it's built traditionally. The key components of the standard build process include:

* **`configure` Scripts:** These scripts, often generated by Autotools, perform system checks (e.g., presence of libraries, compiler capabilities) and generate the Makefiles based on the environment. We need to understand what checks are crucial to replicate them in Zig.
* **Makefiles:** These files define the actual build rules: which C files to compile, with what flags, and how to link them into executables and libraries. Analyzing these will tell us the exact compilation units and linking steps required for each component.
* **Shell Scripts:** Various shell scripts are used for pre-processing, post-processing, and other build-related tasks. We'll need to identify their purpose and potentially reimplement their logic in Zig.
* **Erlang Compiler (`erlc`):** The Erlang compiler is part of OTP and is itself built from Erlang and some C code. Understanding its build process is critical for our bootstrapping strategy.

**Key Areas to Investigate:**

* **`erts` (Erlang Runtime System):** Focus on the C source files in `erts`, their compilation flags (e.g., include paths, optimization levels, preprocessor definitions), and the system libraries they link against (e.g., `libc`, `libm`, `libpthread`).
* **`kernel` and `stdlib`:** Understand how the Erlang source files (`.erl`) in these essential libraries are compiled. This will involve looking at how `erlc` is invoked during the build.
* **External Dependencies:** Identify any external C libraries that Erlang/OTP depends on (e.g., `zlib`, `openssl`, `ncurses`). We need to know how these are detected and linked.

**2. Leveraging the Zig Build System for Erlang/OTP**

Zig's build system, managed by the `build.zig` file, offers a way to define our build process in code. The `build.zig` file in this repository outlines the intended steps. Key features of Zig's build system that we will leverage include:

* **Compilation Units:** Defining compilation units for both C source files (using `@cImport` in the `build.zig` file) and eventually potentially Zig code.
* **Compilation Flags:** Translating compilation flags from the Makefiles into options within the Zig build steps.
* **Linking:** Using Zig's linking capabilities to link against system libraries and manage external dependencies.
* **Custom Build Steps:** Defining custom build steps to handle the compilation of Erlang source files, likely involving a bootstrapping process.

**3. Building the Core BEAM VM with Zig**

The BEAM VM is the foundation. The `build.zig` file contains the initial structure for building the BEAM VM. This involves:

1.  Identifying the core C source files within the `erts` directory.
2.  Creating an executable target in `build.zig` that includes these source files.
3.  Adding the necessary include paths for the C headers.
4.  Defining preprocessor definitions that might be required.
5.  Linking against the system libraries that the BEAM VM depends on (e.g., `libc`, `pthread`, `m`, `z`, `ssl`).

**4. Compiling Erlang Libraries with a Zig-Built Compiler**

This is a crucial and potentially iterative step. The `build.zig` file includes a conceptual outline for this process. Our strategy for compiling the Erlang source files in `kernel`, `stdlib`, etc., will likely involve:

1.  Building a minimal BEAM VM capable of running the Erlang compiler.
2.  Bootstrapping `erlc` (the Erlang compiler).
3.  Integrating the invocation of `erlc` within the `build.zig` file to compile the remaining Erlang source files.

**5. Handling Dependencies**

Erlang/OTP depends on both system libraries and potentially external C libraries. The `build.zig` file demonstrates how we intend to handle these:

1.  Initially linking against system-installed versions of common libraries.
2.  Exploring the possibility of using pure Zig implementations of these libraries in the future (potentially via Zig's package manager).

**6. Testing and Future Directions**

The `build.zig` file currently focuses on the build process. Testing will be a crucial next step, involving running simple Erlang programs and eventually integrating Erlang/OTP's own test suites. Future directions for this project include cross-compilation, performance analysis, and further reducing reliance on C dependencies.

This document provides a foundational understanding of the project. The `build.zig` file contains the initial code structure and comments to guide contributors. As we progress, both this document and the `build.zig` file will be updated with more specific details and challenges encountered. Your contributions and insights are highly valued on this exciting journey!
